/*
** openfile.c for wireframe in /home/benji_epitech/C_Graph_Prog/wireframe
** 
** Made by Benjamin Viguier
** Login   <benjamin.viguier@epitech.eu>
** 
** Started on  Wed Dec  7 09:53:54 2016 Benjamin Viguier
** Last update Wed Dec  7 18:47:11 2016 Benjamin Viguier
*/

#include "my.h"

char		*conca_buffer(char *inp, size_t cur_size,
			      char *buf, size_t b_len)
{
  char		*res;
  t_uint	i;

  res = malloc(sizeof(char) * (b_len + cur_size + 1));
  if (!res)
    return (NULL);
  i = 0;
  my_strncpy(res, inp, cur_size);
  while (i < b_len)
    {
      res[i + cur_size] = buf[i];
      i += 1;
    }
  free(inp);
  return (res);
}

char	*read_to_end(char *file)
{
  int		fd;
  char		buffer[BUF_SIZE];
  char		*res;
  size_t	len;
  size_t	cur_len;

  fd = open(file, O_RDONLY);
  if (fd < 0)
    return (NULL);
  cur_len = 0;
  len = read(fd, buffer, BUF_SIZE);
  while (len)
    {
      res = conca_buffer(res, cur_len, buffer, len);
      if (!res)
	return (NULL);
      cur_len += len;
      len = read(fd, buffer, BUF_SIZE);
    }
  res[cur_len] = '\0';
  return (res);
}

int	incr_int_matrix(t_int_matrix *m, char **file_open)
{
  int	last_cur_w;
  int	cur_w;
  char	**spl_cur;
  int	x;
  int	y;

  y = 0;
  last_cur_w = -1;
  while (y < m->h)
    {
      del_last(file_open[y]);
      spl_cur = my_split(file_open[y], ',', &cur_w);
      if (!spl_cur || ((last_cur_w >= 0) && (cur_w != last_cur_w)))
	return (-1);
      last_cur_w = cur_w;
      x = 0;
      while (x < m->w)
	{
	  m->buffer[y * m->w + x] = my_getnbr(spl_cur[x]);
	  x += 1;
	}
      free(spl_cur);
      y += 1;
    }
  return (0);
}

int	count_w(char **splited_data)
{
  int	i;
  int	j;

  i = 0;
  j = 0;
  while ((*splited_data)[i])
    {
      if ((*splited_data)[i] == ',')
	j += 1;
      i += 1;
    }
  return (j);
}

t_int_matrix	*openfile(char *file)
{
  t_int_matrix	*m;
  char		*data;
  char		**splited_data;
  int		incr_res;

  m = malloc(sizeof(t_int_matrix));
  data = read_to_end(file);
  if (!m || !data)
    return (NULL);
  splited_data = my_split(data, '\n', &(m->h));
  if (!splited_data)
    return (NULL);
  m->w = count_w(splited_data);
  m->buffer = malloc(sizeof(int) * m->w * m->h);
  if (!m->buffer)
    return (NULL);
  incr_res = incr_int_matrix(m, splited_data);
  free(splited_data);
  if (incr_res == -1)
    return (NULL);
  else
    return (m);
}
